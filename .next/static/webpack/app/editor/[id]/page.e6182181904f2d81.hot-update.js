"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/editor/[id]/page",{

/***/ "(app-pages-browser)/./lib/deepseek-config.ts":
/*!********************************!*\
  !*** ./lib/deepseek-config.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateSuggestion: function() { return /* binding */ generateSuggestion; },\n/* harmony export */   getDeepSeekClient: function() { return /* binding */ getDeepSeekClient; },\n/* harmony export */   getDeepSeekModel: function() { return /* binding */ getDeepSeekModel; },\n/* harmony export */   isDeepSeekConfigured: function() { return /* binding */ isDeepSeekConfigured; }\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openai */ \"(app-pages-browser)/./node_modules/openai/index.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n/**\n * Creates and returns an OpenAI compatible client configured for DeepSeek\n */ function getDeepSeekClient() {\n    const apiKey = process.env.DEEPSEEK_API_KEY;\n    if (!apiKey) {\n        throw new Error(\"DEEPSEEK_API_KEY is not set in environment variables\");\n    }\n    return new openai__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        apiKey,\n        baseURL: \"https://api.deepseek.com/v1\",\n        timeout: 15000,\n        maxRetries: 1\n    });\n}\n/**\n * Checks if DeepSeek is configured by testing the API key\n */ async function isDeepSeekConfigured() {\n    try {\n        // Use relative URL for API calls to ensure they work in all environments\n        const baseUrl =  true ? window.location.origin : 0;\n        const url = \"\".concat(baseUrl, \"/api/test-deepseek\");\n        // We'll use a much shorter timeout for configuration checks\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), 5000); // 5 second timeout\n        try {\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    \"Cache-Control\": \"no-cache\"\n                },\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) return false;\n            const data = await response.json();\n            return data.configured;\n        } catch (error) {\n            // If this fails, we'll assume DeepSeek isn't configured\n            return false;\n        } finally{\n            clearTimeout(timeoutId);\n        }\n    } catch (error) {\n        console.error(\"Error checking DeepSeek configuration:\", error);\n        return false;\n    }\n}\n/**\n * Fetches with retry logic\n */ async function fetchWithRetry(url, options) {\n    let retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2, backoff = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 300, timeout = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 8000;\n    // Create a new abort controller for each attempt\n    const controller = new AbortController();\n    // Create a merged signal if the options already had one\n    const originalSignal = options.signal;\n    options.signal = controller.signal;\n    // Set up the timeout\n    const timeoutId = setTimeout(()=>controller.abort(), timeout);\n    // If the original signal aborts, we should abort too\n    const signalListener = ()=>{\n        controller.abort();\n        clearTimeout(timeoutId);\n    };\n    if (originalSignal) {\n        originalSignal.addEventListener(\"abort\", signalListener);\n    }\n    try {\n        const response = await fetch(url, options);\n        // Clean up\n        clearTimeout(timeoutId);\n        if (originalSignal) {\n            originalSignal.removeEventListener(\"abort\", signalListener);\n        }\n        // Only retry on 5xx server errors and network/timeout failures\n        if (!response.ok && response.status >= 500 && retries > 0) {\n            // Wait with exponential backoff before retrying\n            await new Promise((resolve)=>setTimeout(resolve, backoff));\n            return fetchWithRetry(url, options, retries - 1, backoff * 2, timeout);\n        }\n        return response;\n    } catch (error) {\n        // Clean up\n        clearTimeout(timeoutId);\n        if (originalSignal) {\n            originalSignal.removeEventListener(\"abort\", signalListener);\n        }\n        if ((error instanceof TypeError || error.name === \"AbortError\") && retries > 0) {\n            // Network error or timeout - retry with exponential backoff\n            await new Promise((resolve)=>setTimeout(resolve, backoff));\n            return fetchWithRetry(url, options, retries - 1, backoff * 2, timeout);\n        }\n        throw error;\n    }\n}\n/**\n * Generates a suggestion using DeepSeek API\n */ async function generateSuggestion(text) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _options_maxRetries;\n    const maxRetries = (_options_maxRetries = options.maxRetries) !== null && _options_maxRetries !== void 0 ? _options_maxRetries : 2;\n    var _options_timeout;\n    const timeout = (_options_timeout = options.timeout) !== null && _options_timeout !== void 0 ? _options_timeout : 8000; // 8 second default timeout\n    try {\n        // Use relative URL for API calls to ensure they work in all environments\n        const baseUrl =  true ? window.location.origin : 0;\n        const url = \"\".concat(baseUrl, \"/api/generate-suggestion\");\n        // Set up the main controller for the overall operation\n        const controller = new AbortController();\n        // Generate a very minimal context to avoid long processing times\n        // Just use the last few words as context\n        const words = text.split(/\\s+/);\n        const lastWords = words.slice(-10).join(\" \");\n        const response = await fetchWithRetry(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                text: lastWords,\n                maxTokens: options.maxTokens || 15,\n                temperature: options.temperature || 0.7\n            }),\n            signal: controller.signal\n        }, maxRetries, 300, timeout // Use the timeout from options or default\n        );\n        // Handle error responses\n        if (!response.ok) {\n            // If we got a 504, throw a specific timeout error\n            if (response.status === 504) {\n                throw new Error(\"Request timed out. The API may be overloaded.\");\n            }\n            let errorData;\n            try {\n                errorData = await response.json();\n            } catch (e) {\n                errorData = {\n                    error: \"Server error: \".concat(response.status)\n                };\n            }\n            // If we get an authentication error but we have text, generate a simple fallback\n            if (response.status === 401 && lastWords) {\n                console.log(\"Authentication error, using simple client-side fallback\");\n                // Return a simple continuation based on the last word\n                return \"\".concat(lastWords.split(\" \").pop(), \" ...\");\n            }\n            throw new Error(errorData.error || \"Failed to generate suggestion: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (data.fallback) {\n            console.log(\"Server used fallback generation\");\n        }\n        return data.suggestion || \"\";\n    } catch (error) {\n        var _error_message, _error_message1;\n        console.error(\"Error generating suggestion:\", error);\n        // For timeout errors, try to provide a simple fallback rather than failing\n        if (error.name === \"AbortError\" || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"timed out\")) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"504\"))) {\n            if (text) {\n                // Return a very simple continuation based on the last word if possible\n                const lastWord = text.split(/\\s+/).pop() || \"\";\n                if (lastWord.length > 2) {\n                    return \"\".concat(lastWord, \" ...\");\n                }\n            }\n        }\n        throw error;\n    }\n}\n/**\n * Returns the DeepSeek model name\n */ function getDeepSeekModel() {\n    let modelName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"deepseek-chat\";\n    return modelName;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kZWVwc2Vlay1jb25maWcudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRCO0FBVTVCOztDQUVDLEdBQ00sU0FBU0M7SUFDZCxNQUFNQyxTQUFTQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLGdCQUFnQjtJQUUzQyxJQUFJLENBQUNILFFBQVE7UUFDWCxNQUFNLElBQUlJLE1BQU07SUFDbEI7SUFFQSxPQUFPLElBQUlOLDhDQUFNQSxDQUFDO1FBQ2hCRTtRQUNBSyxTQUFTO1FBQ1RDLFNBQVM7UUFDVEMsWUFBWTtJQUNkO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLGVBQWVDO0lBQ3BCLElBQUk7UUFDRix5RUFBeUU7UUFDekUsTUFBTUMsVUFBVSxLQUFrQixHQUFjQyxPQUFPQyxRQUFRLENBQUNDLE1BQU0sR0FBRztRQUN6RSxNQUFNQyxNQUFNLEdBQVcsT0FBUkosU0FBUTtRQUV2Qiw0REFBNEQ7UUFDNUQsTUFBTUssYUFBYSxJQUFJQztRQUN2QixNQUFNQyxZQUFZQyxXQUFXLElBQU1ILFdBQVdJLEtBQUssSUFBSSxPQUFPLG1CQUFtQjtRQUVqRixJQUFJO1lBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNUCxLQUFLO2dCQUNoQ1EsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxpQkFBaUI7Z0JBQ25CO2dCQUNBQyxRQUFRVCxXQUFXUyxNQUFNO1lBQzNCO1lBRUFDLGFBQWFSO1lBRWIsSUFBSSxDQUFDRyxTQUFTTSxFQUFFLEVBQUUsT0FBTztZQUN6QixNQUFNQyxPQUFPLE1BQU1QLFNBQVNRLElBQUk7WUFDaEMsT0FBT0QsS0FBS0UsVUFBVTtRQUN4QixFQUFFLE9BQU9DLE9BQU87WUFDZCx3REFBd0Q7WUFDeEQsT0FBTztRQUNULFNBQVU7WUFDUkwsYUFBYVI7UUFDZjtJQUNGLEVBQUUsT0FBT2EsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsMENBQTBDQTtRQUN4RCxPQUFPO0lBQ1Q7QUFDRjtBQUVBOztDQUVDLEdB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Z0JBQzVDLElBQUlLLFNBQVNDLE1BQU0sR0FBRyxHQUFHO29CQUN2QixPQUFPLEdBQVksT0FBVEQsVUFBUztnQkFDckI7WUFDRjtRQUNGO1FBRUEsTUFBTW5DO0lBQ1I7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU3FDO1FBQWlCQyxZQUFBQSxpRUFBb0I7SUFDbkQsT0FBT0E7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZGVlcHNlZWstY29uZmlnLnRzP2E3NzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9wZW5BSSBmcm9tIFwib3BlbmFpXCI7XG5cbi8vIERlZXBTZWVrIGNvbmZpZ3VyYXRpb25cbmludGVyZmFjZSBEZWVwU2Vla09wdGlvbnMge1xuICBtYXhUb2tlbnM/OiBudW1iZXI7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuICBtYXhSZXRyaWVzPzogbnVtYmVyO1xuICB0aW1lb3V0PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gT3BlbkFJIGNvbXBhdGlibGUgY2xpZW50IGNvbmZpZ3VyZWQgZm9yIERlZXBTZWVrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWVwU2Vla0NsaWVudCgpOiBPcGVuQUkge1xuICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5ERUVQU0VFS19BUElfS0VZO1xuICBcbiAgaWYgKCFhcGlLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJERUVQU0VFS19BUElfS0VZIGlzIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzXCIpO1xuICB9XG4gIFxuICByZXR1cm4gbmV3IE9wZW5BSSh7XG4gICAgYXBpS2V5LFxuICAgIGJhc2VVUkw6IFwiaHR0cHM6Ly9hcGkuZGVlcHNlZWsuY29tL3YxXCIsIC8vIERlZXBTZWVrJ3MgT3BlbkFJIGNvbXBhdGlibGUgZW5kcG9pbnRcbiAgICB0aW1lb3V0OiAxNTAwMCwgLy8gMTUgc2Vjb25kIHRpbWVvdXQgZm9yIHRoZSBEZWVwU2VlayBTREtcbiAgICBtYXhSZXRyaWVzOiAxLCAgLy8gTGltaXQgcmV0cmllcyB0byBhdm9pZCBleGNlc3NpdmUgdGltZW91dHNcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIERlZXBTZWVrIGlzIGNvbmZpZ3VyZWQgYnkgdGVzdGluZyB0aGUgQVBJIGtleVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNEZWVwU2Vla0NvbmZpZ3VyZWQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIHJlbGF0aXZlIFVSTCBmb3IgQVBJIGNhbGxzIHRvIGVuc3VyZSB0aGV5IHdvcmsgaW4gYWxsIGVudmlyb25tZW50c1xuICAgIGNvbnN0IGJhc2VVcmwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiAnJztcbiAgICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfS9hcGkvdGVzdC1kZWVwc2Vla2A7XG4gICAgXG4gICAgLy8gV2UnbGwgdXNlIGEgbXVjaCBzaG9ydGVyIHRpbWVvdXQgZm9yIGNvbmZpZ3VyYXRpb24gY2hlY2tzXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgNTAwMCk7IC8vIDUgc2Vjb25kIHRpbWVvdXRcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICB9LFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIGRhdGEuY29uZmlndXJlZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWYgdGhpcyBmYWlscywgd2UnbGwgYXNzdW1lIERlZXBTZWVrIGlzbid0IGNvbmZpZ3VyZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjaGVja2luZyBEZWVwU2VlayBjb25maWd1cmF0aW9uOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2hlcyB3aXRoIHJldHJ5IGxvZ2ljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoV2l0aFJldHJ5KFxuICB1cmw6IHN0cmluZywgXG4gIG9wdGlvbnM6IFJlcXVlc3RJbml0LFxuICByZXRyaWVzID0gMixcbiAgYmFja29mZiA9IDMwMCxcbiAgdGltZW91dCA9IDgwMDBcbik6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgLy8gQ3JlYXRlIGEgbmV3IGFib3J0IGNvbnRyb2xsZXIgZm9yIGVhY2ggYXR0ZW1wdFxuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBcbiAgLy8gQ3JlYXRlIGEgbWVyZ2VkIHNpZ25hbCBpZiB0aGUgb3B0aW9ucyBhbHJlYWR5IGhhZCBvbmVcbiAgY29uc3Qgb3JpZ2luYWxTaWduYWwgPSBvcHRpb25zLnNpZ25hbDtcbiAgb3B0aW9ucy5zaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbDtcbiAgXG4gIC8vIFNldCB1cCB0aGUgdGltZW91dFxuICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dCk7XG4gIFxuICAvLyBJZiB0aGUgb3JpZ2luYWwgc2lnbmFsIGFib3J0cywgd2Ugc2hvdWxkIGFib3J0IHRvb1xuICBjb25zdCBzaWduYWxMaXN0ZW5lciA9ICgpID0+IHtcbiAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG4gIFxuICBpZiAob3JpZ2luYWxTaWduYWwpIHtcbiAgICBvcmlnaW5hbFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIHNpZ25hbExpc3RlbmVyKTtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXBcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICBpZiAob3JpZ2luYWxTaWduYWwpIHtcbiAgICAgIG9yaWdpbmFsU2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgc2lnbmFsTGlzdGVuZXIpO1xuICAgIH1cbiAgICBcbiAgICAvLyBPbmx5IHJldHJ5IG9uIDV4eCBzZXJ2ZXIgZXJyb3JzIGFuZCBuZXR3b3JrL3RpbWVvdXQgZmFpbHVyZXNcbiAgICBpZiAoKCFyZXNwb25zZS5vayAmJiByZXNwb25zZS5zdGF0dXMgPj0gNTAwKSAmJiByZXRyaWVzID4gMCkge1xuICAgICAgLy8gV2FpdCB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYgYmVmb3JlIHJldHJ5aW5nXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgYmFja29mZikpO1xuICAgICAgcmV0dXJuIGZldGNoV2l0aFJldHJ5KHVybCwgb3B0aW9ucywgcmV0cmllcyAtIDEsIGJhY2tvZmYgKiAyLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIENsZWFuIHVwXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgaWYgKG9yaWdpbmFsU2lnbmFsKSB7XG4gICAgICBvcmlnaW5hbFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHNpZ25hbExpc3RlbmVyKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciB8fCBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpICYmIHJldHJpZXMgPiAwKSB7XG4gICAgICAvLyBOZXR3b3JrIGVycm9yIG9yIHRpbWVvdXQgLSByZXRyeSB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBiYWNrb2ZmKSk7XG4gICAgICByZXR1cm4gZmV0Y2hXaXRoUmV0cnkodXJsLCBvcHRpb25zLCByZXRyaWVzIC0gMSwgYmFja29mZiAqIDIsIHRpbWVvdXQpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHN1Z2dlc3Rpb24gdXNpbmcgRGVlcFNlZWsgQVBJXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVN1Z2dlc3Rpb24oXG4gIHRleHQ6IHN0cmluZyxcbiAgb3B0aW9uczogRGVlcFNlZWtPcHRpb25zID0ge31cbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IG1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPz8gMjtcbiAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCA/PyA4MDAwOyAvLyA4IHNlY29uZCBkZWZhdWx0IHRpbWVvdXRcbiAgXG4gIHRyeSB7XG4gICAgLy8gVXNlIHJlbGF0aXZlIFVSTCBmb3IgQVBJIGNhbGxzIHRvIGVuc3VyZSB0aGV5IHdvcmsgaW4gYWxsIGVudmlyb25tZW50c1xuICAgIGNvbnN0IGJhc2VVcmwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiAnJztcbiAgICBjb25zdCB1cmwgPSBgJHtiYXNlVXJsfS9hcGkvZ2VuZXJhdGUtc3VnZ2VzdGlvbmA7XG5cbiAgICAvLyBTZXQgdXAgdGhlIG1haW4gY29udHJvbGxlciBmb3IgdGhlIG92ZXJhbGwgb3BlcmF0aW9uXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBcbiAgICAvLyBHZW5lcmF0ZSBhIHZlcnkgbWluaW1hbCBjb250ZXh0IHRvIGF2b2lkIGxvbmcgcHJvY2Vzc2luZyB0aW1lc1xuICAgIC8vIEp1c3QgdXNlIHRoZSBsYXN0IGZldyB3b3JkcyBhcyBjb250ZXh0XG4gICAgY29uc3Qgd29yZHMgPSB0ZXh0LnNwbGl0KC9cXHMrLyk7XG4gICAgY29uc3QgbGFzdFdvcmRzID0gd29yZHMuc2xpY2UoLTEwKS5qb2luKCcgJyk7XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeShcbiAgICAgIHVybCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdGV4dDogbGFzdFdvcmRzLCAvLyBTZW5kIG9ubHkgdGhlIGxhc3QgZmV3IHdvcmRzIHJhdGhlciB0aGFuIHRoZSBmdWxsIHRleHRcbiAgICAgICAgICBtYXhUb2tlbnM6IG9wdGlvbnMubWF4VG9rZW5zIHx8IDE1LCAvLyBNaW5pbWFsIHRva2VucyBmb3IgZmFzdGVyIHJlc3BvbnNlc1xuICAgICAgICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLnRlbXBlcmF0dXJlIHx8IDAuNyxcbiAgICAgICAgfSksXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICB9LFxuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIDMwMCwgLy8gSW5pdGlhbCBiYWNrb2ZmIGluIG1zXG4gICAgICB0aW1lb3V0IC8vIFVzZSB0aGUgdGltZW91dCBmcm9tIG9wdGlvbnMgb3IgZGVmYXVsdFxuICAgICk7XG5cbiAgICAvLyBIYW5kbGUgZXJyb3IgcmVzcG9uc2VzXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgLy8gSWYgd2UgZ290IGEgNTA0LCB0aHJvdyBhIHNwZWNpZmljIHRpbWVvdXQgZXJyb3JcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDUwNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZWQgb3V0LiBUaGUgQVBJIG1heSBiZSBvdmVybG9hZGVkLicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgZXJyb3JEYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvckRhdGEgPSB7IGVycm9yOiBgU2VydmVyIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHdlIGdldCBhbiBhdXRoZW50aWNhdGlvbiBlcnJvciBidXQgd2UgaGF2ZSB0ZXh0LCBnZW5lcmF0ZSBhIHNpbXBsZSBmYWxsYmFja1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxICYmIGxhc3RXb3Jkcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkF1dGhlbnRpY2F0aW9uIGVycm9yLCB1c2luZyBzaW1wbGUgY2xpZW50LXNpZGUgZmFsbGJhY2tcIik7XG4gICAgICAgIC8vIFJldHVybiBhIHNpbXBsZSBjb250aW51YXRpb24gYmFzZWQgb24gdGhlIGxhc3Qgd29yZFxuICAgICAgICByZXR1cm4gYCR7bGFzdFdvcmRzLnNwbGl0KCcgJykucG9wKCl9IC4uLmA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXJyb3JEYXRhLmVycm9yIHx8IGBGYWlsZWQgdG8gZ2VuZXJhdGUgc3VnZ2VzdGlvbjogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGlmIChkYXRhLmZhbGxiYWNrKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlNlcnZlciB1c2VkIGZhbGxiYWNrIGdlbmVyYXRpb25cIik7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYXRhLnN1Z2dlc3Rpb24gfHwgJyc7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2VuZXJhdGluZyBzdWdnZXN0aW9uOlwiLCBlcnJvcik7XG4gICAgXG4gICAgLy8gRm9yIHRpbWVvdXQgZXJyb3JzLCB0cnkgdG8gcHJvdmlkZSBhIHNpbXBsZSBmYWxsYmFjayByYXRoZXIgdGhhbiBmYWlsaW5nXG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygndGltZWQgb3V0JykgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJzUwNCcpKSB7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICAvLyBSZXR1cm4gYSB2ZXJ5IHNpbXBsZSBjb250aW51YXRpb24gYmFzZWQgb24gdGhlIGxhc3Qgd29yZCBpZiBwb3NzaWJsZVxuICAgICAgICBjb25zdCBsYXN0V29yZCA9IHRleHQuc3BsaXQoL1xccysvKS5wb3AoKSB8fCAnJztcbiAgICAgICAgaWYgKGxhc3RXb3JkLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICByZXR1cm4gYCR7bGFzdFdvcmR9IC4uLmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBEZWVwU2VlayBtb2RlbCBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWVwU2Vla01vZGVsKG1vZGVsTmFtZTogc3RyaW5nID0gXCJkZWVwc2Vlay1jaGF0XCIpOiBzdHJpbmcge1xuICByZXR1cm4gbW9kZWxOYW1lO1xufSAiXSwibmFtZXMiOlsiT3BlbkFJIiwiZ2V0RGVlcFNlZWtDbGllbnQiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiREVFUFNFRUtfQVBJX0tFWSIsIkVycm9yIiwiYmFzZVVSTCIsInRpbWVvdXQiLCJtYXhSZXRyaWVzIiwiaXNEZWVwU2Vla0NvbmZpZ3VyZWQiLCJiYXNlVXJsIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJ1cmwiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJvayIsImRhdGEiLCJqc29uIiwiY29uZmlndXJlZCIsImVycm9yIiwiY29uc29sZSIsImZldGNoV2l0aFJldHJ5Iiwib3B0aW9ucyIsInJldHJpZXMiLCJiYWNrb2ZmIiwib3JpZ2luYWxTaWduYWwiLCJzaWduYWxMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3RhdHVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJUeXBlRXJyb3IiLCJuYW1lIiwiZ2VuZXJhdGVTdWdnZXN0aW9uIiwidGV4dCIsIndvcmRzIiwic3BsaXQiLCJsYXN0V29yZHMiLCJzbGljZSIsImpvaW4iLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1heFRva2VucyIsInRlbXBlcmF0dXJlIiwiZXJyb3JEYXRhIiwiZSIsImxvZyIsInBvcCIsImZhbGxiYWNrIiwic3VnZ2VzdGlvbiIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsImxhc3RXb3JkIiwibGVuZ3RoIiwiZ2V0RGVlcFNlZWtNb2RlbCIsIm1vZGVsTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/deepseek-config.ts\n"));

/***/ })

});